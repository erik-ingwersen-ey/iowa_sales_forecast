"""
Compute the Pylint score of a Python module or folder.

.. important::

    This script requires `pylint.epylint` module.
    This module has been deprecated in newer versions of `pylint`.
    Therefore, you might need to install an older version of `pylint` package.
    To install a version of `pylint` that is compatible with this script
    you can run the following command:

    .. code-block:: bash

         pip install pylint==2.15.10


How to Use
----------
To use this script, run the following command in the terminal:

.. code-block:: bash

    python pylint_score.py <path_to_module_or_folder>

Additionally, you can provide the following optional arguments:

- `--output-path`: Path to save the results in an Excel file.
- `--verbose`: The verbose mode. If set to True, print the scores.

For example, to score the `../src/wip` folder and save the results in an Excel file,
run the following command:

.. code-block:: bash

    python pylint_score.py ../src/wip --output-path ../outputs/pylint_scores.xlsx

The command above will compute the scores to every Python file inside `src/wip`.
Then it will save the results in an Excel file located at `../outputs/pylint_scores.xlsx`.

.. tip::

    The above command that lints the entire `wip` package might take an significant
    amount of time to finish executing.


Notes
-----
The examples shown above assume that you are running the script from inside the
`scripts` folder. If you are running the script from the root folder, then you
need to adjust the paths accordingly.

Although Pylint scores provide some context about the source code quality
and overall complexity, it's important to keep in mind that failing in some of
its checks does not necessarily mean that there's something wrong with your code.
Likewise, having a perfect Pylint score does not guarantee that your code is perfect
and bug-free. Therefore, you should always view the scores generated by Pylint
with a grain of salt.

"""
from __future__ import annotations
from typing import Dict
import warnings

import argparse

from pathlib import Path
import pylint.epylint as lint

import pandas as pd
from rich.progress import Progress

warnings.filterwarnings('ignore')


def score_multiple_modules(folder_path: Path | str) -> float | Dict[str, float]:
    """
    Score Python modules inside a folder using pylint.

    The function returns a dictionary, where each module's path is the
    key and the score its value.

    Parameters
    ----------
    folder_path : Path | str
        Path to the folder, with the Python modules to be scored.

    Returns
    -------
    Dict[str, float]
        Returns a dictionary with the score of every Python
        file found inside that folder.

    See Also
    --------
    score_module : Score a Python module using pylint.
    """
    module_paths = list(folder_path.glob("**/*.py"))
    with Progress(transient=True) as progress:
        task = progress.add_task("Scoring Module: ", total=len(module_paths))
        scores = {}
        for module in module_paths:
            progress.tasks[0].description = f"Scoring Module: {str(module)!r}"
            scores[module] = score_module(module)
            progress.advance(task)
    return scores


def score_module(module_path: Path | str) -> float | Dict[str, float]:
    """
    Score a Python module or folder using pylint.

    The function returns a score between 0 and 10, or a
    dictionary of scores if the path provided is a folder.

    Parameters
    ----------
    module_path : Path | str
        Path to the Python module to be scored.

    Returns
    -------
    float | Dict[str, float]
        Returns score between 0 and 10, if `module_path` is a Python file.
        Otherwise, if `module_path` is a folder path, returns a dictionary
        with the score of every Python file found inside that folder.
    """
    _module_path = Path(module_path)

    # Check if the module path is valid.
    if not _module_path.exists():
        raise FileNotFoundError(f"{module_path} does not exist.")

    # Check if the module path is a folder.
    # If it is, then run the function for each Python
    # file found inside this folder.
    if _module_path.is_dir():
        return score_multiple_modules(_module_path)

    # Check if the module path is a Python file.
    if _module_path.suffix != '.py':
        raise ValueError(f"{module_path} is not a valid Python file.")

    # Run pylint on the module
    (pylint_stdout, _) = lint.py_run(str(module_path), return_std=True)  # noqa

    # Parse the pylint output to extract the score
    for line in pylint_stdout.getvalue().splitlines():
        if "Your code has been rated at" in line:
            # Extract the score from the line
            score_str = line.split(' ')[7]  # Extract the score substring, e.g., "7.86/10"
            score = float(score_str.split('/')[0])  # Extract the score value e.g., 7.86
            return score

    # Return 0 if the score is not found in pylint's output
    return 0.0


def save_scores_to_excel(scores: Dict[str, float], output_path: str) -> None:
    """Save scores to an Excel file."""
    data = pd.DataFrame(list(scores.items()), columns=["Module", "Score"])
    data["Name"] = data["Module"].apply(lambda value: Path(value).name)
    data[["Module", "Name", "Score"]].to_excel(output_path, index=False)


def main():
    """Score Python modules using pylint"""
    parser = argparse.ArgumentParser(description="Score Python modules using pylint.")

    parser.add_argument("path", type=str,
                        help="Path to Python module or folder to be scored.")
    parser.add_argument("--verbose", type=bool, default=False,
                        help="Verbose mode. If set to True, print the scores.")
    parser.add_argument("--output-path", type=str,
                        help="Path to save the results in an Excel file.")

    args = parser.parse_args()

    scores = score_module(args.path)

    if args.verbose:
        for module, score in scores.items():
            print(f"{module}: {score}")

    if args.output_path:
        excel_path = Path(args.output_path)
        if excel_path.is_dir():
            excel_path = (
                excel_path
                .with_suffix("")
                .joinpath("pylint_scores")
                .with_suffix(".xlsx")
            )
        elif excel_path.is_file() and not excel_path.suffix == ".xlsx":
            excel_path = excel_path.with_suffix(".xlsx")

        excel_path.parent.mkdir(exist_ok=True, parents=True)
        save_scores_to_excel(scores, str(excel_path))


if __name__ == "__main__":
    main()